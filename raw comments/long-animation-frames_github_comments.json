[
    {
        "id": 1987797165,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/5",
        "created_at": "2023-08-23T10:35:25Z",
        "updated_at": "2023-08-23T10:35:25Z",
        "body": "The way I see it (and reflecting some internal team conversations with @mmocny and @tdresser), bad responsiveness can be caused by:\r\n1. long event processing. event timing already captures this. Scripts that correlate between the entries can help here as well to give you more attribution that LoAF provides. \r\n2. compositor congestion, which delays both input and paint. LoAF doesn't help there.\r\n3. General main-thread congestion. This is where LoAF is useful regardless of INP/event-timing: if your main thread is running a lot of things in a blocking way, it has a high chance to fall on one event or another, and capturing exactly which event fell on which LoAF is perhaps a bit of a red herring.\r\n\r\nSo for someone that's debugging INP, it would be best to start by understanding which kind of problem they have out of the (3), and see if correlating the exact event-timing entry with LoAF is what would help them with that.\r\n\r\n\r\n\r\n",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987796788,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/4",
        "created_at": "2023-09-20T07:36:55Z",
        "updated_at": "2023-09-20T07:36:55Z",
        "body": "+1\r\n\r\nIt would be great to avoid the need to use rAF polling for measuring smoothness. Evaluating smoothness with the 50ms threshold is possible but provide a less accurate signal than what we would like.\r\n\r\nEasy crossing with Event Timing entries is another interesting scenario.",
        "user": "nhelfman",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987796055,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2023-10-03T17:41:30Z",
        "updated_at": "2023-10-03T17:41:30Z",
        "body": "Thanks for posting the issue!\r\nNote that scripts have a `sourceLocation` property, which includes the function name. Their syntax is `function@scriptSourceURL:characterIndex`.\r\n\r\nSo the way to do what you specifically asked for is:\r\n```js\r\nnew ResizeObserverEntry(function SourceOfCode([entry]: ResizeObserverEntry[]) {\r\n  // ...\r\n}).obeserve(target.current);\r\n```\r\nAnd this would appear in the entry's `sourceLocation` as `SourceOfCode@myScriptURL.com:123` or some such.\r\n",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987796060,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2023-10-03T18:45:05Z",
        "updated_at": "2023-10-03T18:45:05Z",
        "body": "This makes sense. I can make this work. For my specific case I think I would want something like\r\n```ts\r\nconst cb = ([entry]: ResizeObserverEntry[]) => {\r\n  // ...\r\n}\r\nObject.defineProperty(cb, 'name', { value: 'SourceOfCode' });\r\nnew ResizeObserver(cb).obeserve(target.current);\r\n```",
        "user": "jarmit",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987796065,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2023-10-18T15:43:24Z",
        "updated_at": "2023-10-18T15:43:24Z",
        "body": "Reopening, there are use cases where this can really be useful. CC @mmocny ",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987796069,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2023-10-18T20:53:43Z",
        "updated_at": "2023-10-18T20:53:43Z",
        "body": "Reading the original request, I see reference to:\r\n\r\n> function is a common function that is used multiple times within the code base\r\n\r\nBut later I only see reference to just making sure a nice name value is exposed.  Is it actually important to somehow differentiate the \"context\" from which a particular callback is invoked?  I'm not sure how often that would come up...\r\n\r\n---\r\n\r\nSecond, if you really want to control labelling, and do this in a way where the developer is explicitly provide a hint-- I wonder if just regular User Timings aren't both sufficient and more flexible?\r\n\r\nJust `performance.measure()` the time spent in specific sections of code (function boundary or whatever you want) and then use LoAF script attribution timestamps to intersect time ranges of your user timings.\r\n\r\nThat way, you can measure all the time ranges for that code, but also filter to cases where it contributed to an overall long-running script within a LoAF.\r\n\r\n---\r\n\r\nThat said, I think it may be valuable if LoAF could do more attribution splitting automatically, on finer boundaries beyond just \"tasks\".  For example, in cases where multiple continuations are registered on a shared promise.  Or where a script calls back into previously registered handlers, but in ways where there isn't a 'hop' though some web platform api (like setTimeout) etc.\r\n\r\nOne (far fetched) idea that comes to mind is perhaps any time an AsyncContext is explicitly switched, if that api ever does take off?\r\n\r\nOf course, a last option is to just rely on yield points, and use that as additional motivation for developers to just yield!",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987796072,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2023-10-19T09:03:49Z",
        "updated_at": "2023-10-19T09:03:49Z",
        "body": "> Reading the original request, I see reference to:\r\n> \r\n> > function is a common function that is used multiple times within the code base\r\n> \r\n> But later I only see reference to just making sure a nice name value is exposed. Is it actually important to somehow differentiate the \"context\" from which a particular callback is invoked? I'm not sure how often that would come up...\r\n> \r\n> Second, if you really want to control labelling, and do this in a way where the developer is explicitly provide a hint-- I wonder if just regular User Timings aren't both sufficient and more flexible?\r\n\r\nIt is, but it can also add a lot of noise. The difference here is that this is \"measure but discard if it's not a LoAF\".\r\n\r\n> That said, I think it may be valuable if LoAF could do more attribution splitting automatically, on finer boundaries beyond just \"tasks\". For example, in cases where multiple continuations are registered on a shared promise. Or where a script calls back into previously registered handlers, but in ways where there isn't a 'hop' though some web platform api (like setTimeout) etc.\r\n> \r\n> One (far fetched) idea that comes to mind is perhaps any time an AsyncContext is explicitly switched, if that api ever does take off?\r\n> \r\n> Of course, a last option is to just rely on yield points, and use that as additional motivation for developers to just yield!\r\n\r\nThose are interesting ideas, I still don't see anything actionable there but let's continue the conversation.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987796073,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2023-11-07T08:44:54Z",
        "updated_at": "2023-11-07T08:44:54Z",
        "body": "+1 to consider improving this use case.\r\n\r\nThere are several RUM providers wrapping Callback/functions that would be flagged by LoAF as Long LoAFs triggers hiding the real Script sourceLocation information...",
        "user": "gilbertococchi",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988645676,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/9",
        "created_at": "2023-11-08T19:23:06Z",
        "updated_at": "2023-11-08T19:23:06Z",
        "body": "I am realizing that this isn't a spec question, just implementation, so moving to crbug.\r\n\r\nhttps://bugs.chromium.org/p/chromium/issues/detail?id=1500696",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987795603,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/2",
        "created_at": "2023-11-10T14:17:30Z",
        "updated_at": "2023-11-10T14:17:30Z",
        "body": "Idea: Perhaps just changing LoAF to treat `EventTarget` listeners as unique entry-point would be the perfect interface for this use case?\r\n\r\nInstead of a library managing its own callback queue and then somehow scheduling those callbacks-- thats already what EventTarget and dispatchEvent does, and there is existing precedent with normal page events already splitting up script attribution on event listener calls.\r\n\r\nLoAF script \"type\" and \"name\" attribution would also be a lot more useful that way, not just solving the \"sourceLocation\" problem.\r\n\r\nAnd EventTarget dispatches listeners synchronously, which addresses the concern with just using yield/postTask.  If you explicitly want to be asynchronous, you can use explicit scheduling.",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987795607,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/2",
        "created_at": "2023-11-16T19:18:46Z",
        "updated_at": "2023-11-16T19:18:46Z",
        "body": "As we spoke in a private chat, this wouldn't work in terms of microtask checkpoints. a \"real\" entry point would call those custom entry points which would add tasks to the microtask queue, and that queue would then be filled with microtasks from different sources without a way to measure them separately. I think w3c/long-animation-frames#3 is a more doable approach.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988645197,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/8",
        "created_at": "2023-11-29T19:41:33Z",
        "updated_at": "2023-11-29T19:41:33Z",
        "body": "The thing about inferring blockingDuration from scripts is that you can miss the following contributors to blocking:\r\n- multiple scripts that are less than 5ms each\r\n- Time spent in things other than scripts, e.g. serializing messages for `postMessage`\r\n\r\nI see a few alternative ways about this:\r\n1. Expose \"longest work task\" instead of `blockingDuration` (they're interchangeable, and \"longest work task\" is perhaps simpler to reason about)\r\n2. Only count the last task before the LoAF as contributing to it. This is where I went originally with LoAF... It's like saying \"you didn't really have a rendering opportunity after the earlier tasks, because we don't give you very frequent ones unless there's input/animation\".\r\n3.  Forget `blockingDuration`. Perhaps it doesn't need to be deduced at all... If you have a LoAF, it means that your main thread was congested. The fact that you split it into tasks was nice but the first task that required a presentation update still had to wait before rendering because there was lots of other main-thread stuff going on.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988645205,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/8",
        "created_at": "2023-11-29T20:53:15Z",
        "updated_at": "2023-11-29T20:53:15Z",
        "body": "RE: 1 --I like that its a bit more interoperable with the Long Tasks api-- but it's also less flexible to evolve.  I could imagine adding more to blockingTime than just one task.  But maybe you general point is that exposing a \"total blocking duration\", without subtracting 50ms or including rendering time automatically, is easier to understand?\r\n\r\nRE 2: --Interesting.  That makes some sense...  On the other hand, today LoAF will already slice tasks at processingEnd whenever we know we don't need rendering (i.e. fallback to LongTask time).  And so this proposal would be similar.  Tasks which aren't immediately followed by rendering are \"just tasks\", and not really LoAFs, from the perspective of the \"blocking\" concept.  So we'd have [Task] as distinct entry, then [Task] nested within LoAF but outside \"blocking\" time, and then [Task+Rendering].  If we believe that is the right way, then maybe we just split LoAF entries, and make LoAF.duration == blockingDuration?\r\n\r\nRE 3: -- I think I am mostly in this camp right now.  I do think right now many pages will report long LoAFs which are due to render-throttling and may not be the \"fault\" of the page, but its also a true representation of UX.  So it just comes down to how the data is interpreted...",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988645211,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/8",
        "created_at": "2023-12-04T15:39:34Z",
        "updated_at": "2023-12-04T15:39:34Z",
        "body": "Some partners are finding `blockingDuration` useful, as they correlate to INP better than duration.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987797173,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/5",
        "created_at": "2024-01-03T21:49:02Z",
        "updated_at": "2024-01-03T21:49:02Z",
        "body": "The main reason we're adding LoAF is to better explain INP entries.  Adding an explicit link between an INP entry and its LoAF sounds logical.",
        "user": "vegerot",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988644639,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/7",
        "created_at": "2024-01-10T15:36:20Z",
        "updated_at": "2024-01-10T15:36:20Z",
        "body": "Gathering RUM data with PageVitals, I'm trying to get familiar with the different results being sent from the LoAF API.\r\n\r\nI think `type` is a great name for `event-listener`, `classic-script`, `user-callback`, `promise-resolve`, ... so I'd rather keep that.\r\n\r\nRenaming `name` to `invoker` could be a good idea because if gives the developer a better notion of what this really means. \r\n\r\nIn the case of `type` \"classic-script\" it's a bit redundant to have the script URL both in the `name` (or `invoker`) and the `sourceLocation`. It looks like they are the same in this case - but where `sourceLocation` may also have the invoked entry function as well as the column number.\r\n",
        "user": "lasseschou",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988644650,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/7",
        "created_at": "2024-01-10T15:58:44Z",
        "updated_at": "2024-01-10T15:58:44Z",
        "body": "> Gathering RUM data with PageVitals, I'm trying to get familiar with the different results being sent from the LoAF API.\r\n> \r\n> I think `type` is a great name for `event-listener`, `classic-script`, `user-callback`, `promise-resolve`, ... so I'd rather keep that.\r\n> \r\n> Renaming `name` to `invoker` could be a good idea because if gives the developer a better notion of what this really means.\r\n> \r\n> In the case of `type` \"classic-script\" it's a bit redundant to have the script URL both in the `name` (or `invoker`) and the `sourceLocation`. It looks like they are the same in this case - but where `sourceLocation` may also have the invoked entry function as well as the column number.\r\n\r\nThe reason to have anything at all in `name` is because in the future we might want to make these nested performance entries available via `performance.getEntriesByName()`, though this is likely a YAGNI.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988644660,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/7",
        "created_at": "2024-01-11T12:09:06Z",
        "updated_at": "2024-01-11T12:13:09Z",
        "body": "~~With @noamr proposal, we would no longer be able to use `performance.getEntriesByName()` to collect all LoAF. What could we use instead, `performance.getEntries().filter(x => x.constructor.name == 'PerformanceLongAnimationFrameTiming')`? (whether or not it's relevant is another question, I'm just trying to wrap my mind around it).~~\r\n\r\n~~I feel like whether we keep `name` for `event-listener`, `classic-script`, `user-callback`, `promise-resolve` goes further that LoAF. `PerformanceResourceTimings` have names with URLs. `PerformancePaintTimings` have names that are more alike to what @lasseschou calls `invoker`, I feel it's already quite inconsistent. But using `performance.getEntriesByName()` to retrieve a specific kind of LoAF makes sense so why not.~~",
        "user": "borisschapira",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988644667,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/7",
        "created_at": "2024-01-11T12:11:21Z",
        "updated_at": "2024-01-11T12:11:21Z",
        "body": "> With @noamr proposal, we would no longer be able to use `performance.getEntriesByName()` to collect all LoAF. \r\n\r\nTo clarify, this is only about the LoAF's `scripts`, which ATM are not retrieved with `getEntriesByName`.\r\n",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988644670,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/7",
        "created_at": "2024-01-11T12:13:24Z",
        "updated_at": "2024-01-11T12:13:24Z",
        "body": "Oh sorry, I'll think about it again, then.",
        "user": "borisschapira",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988644680,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/7",
        "created_at": "2024-01-11T12:35:18Z",
        "updated_at": "2024-01-11T12:35:18Z",
        "body": "In `PerformanceNavigationTiming`, `type` is a string representing the navigation type. `event-listener`, `classic-script`, etc. are not Script types, so for the sake of spec coherence, I feel like `type` is not necessarily adapted.\r\n\r\nIn `PerformanceServerTiming`, `name` is a string representing the name of the timing.  I feel that `event-listener`, `classic-script`, etc. are not names either, rather qualifiers.\r\n\r\nCouldn't they be `entryType` instead? `script` is quite redundant there\u2026",
        "user": "borisschapira",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988644686,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/7",
        "created_at": "2024-01-11T12:38:06Z",
        "updated_at": "2024-01-11T12:39:03Z",
        "body": "> In `PerformanceNavigationTiming`, `type` is a string representing the navigation type. `event-listener`, `classic-script`, etc. are not Script types, so for the sake of spec coherence, I feel like `type` is not necessarily adapted.\r\n> \r\n> In `PerformanceServerTiming`, `name` is a string representing the name of the timing. I feel that `event-listener`, `classic-script`, etc. are not names either, rather qualifiers.\r\n> \r\n> Couldn't they be `entryType` instead? `script` is quite redundant there\u2026\r\n\r\nThat's an option. They're not exactly the type of script, I thought to rename that `invokerType`.\r\nIn most cases the `entryType` matches the IDL type (e.g. `resource` matches to `PerformanceResourceTiming`)",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988644696,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/7",
        "created_at": "2024-01-11T14:14:31Z",
        "updated_at": "2024-01-11T14:14:31Z",
        "body": "Am with @lasseschou, `type` feels more descriptive than `name` for `event-listener`, `script-block` etc..\r\n`invoker` is very clear, like that, though DevTools > Network panel uses `initiator`, which is also quite descriptive?",
        "user": "aarontgrogg",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988644712,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/7",
        "created_at": "2024-01-11T14:15:18Z",
        "updated_at": "2024-01-11T14:15:18Z",
        "body": "I think perhaps `invokerType` rather than `type` though, e.g. the `entryType` is still `script` (maps with the IDL `PerformanceScriptTiming`)",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1988644720,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/7",
        "created_at": "2024-01-11T14:52:07Z",
        "updated_at": "2024-01-11T14:52:07Z",
        "body": "So, `invoker` + `invokerType` or `initiator` + `initiatorType`, then? I must say I like `initiator`.",
        "user": "borisschapira",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987797177,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/5",
        "created_at": "2024-01-19T18:24:07Z",
        "updated_at": "2024-01-19T18:24:07Z",
        "body": "@noamr based on what you said it seems that more important than linking LoAF to INP would be to breakdown the 3 phases of INP (Input delay, Processing time and Presentation delay). Is it possible to do that with the current APIs? I know we can see that in chrome devtools but It would be good to track it in RUM",
        "user": "lebreRafael",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987797180,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/5",
        "created_at": "2024-01-19T19:04:48Z",
        "updated_at": "2024-01-19T19:04:48Z",
        "body": "> @noamr based on what you said it seems that more important than linking LoAF to INP would be to breakdown the 3 phases of INP (Input delay, Processing time and Presentation delay). Is it possible to do that with the current APIs? I know we can see that in chrome devtools but It would be good to track it in RUM\n\nEvent timing gives you precisely that breakdown, yes.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987793656,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/1",
        "created_at": "2024-01-27T18:50:29Z",
        "updated_at": "2024-01-29T11:02:20Z",
        "body": "This is critical for us, since we use firstUIEventTimestamp to calculate rum INP.Please find a solution for this\ud83d\ude4f",
        "user": "anatdagan",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987793659,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/1",
        "created_at": "2024-01-29T11:03:27Z",
        "updated_at": "2024-01-29T11:03:27Z",
        "body": "@anatdagan could you please explain a little more about how this impacts you? You cannot use `firstUIEventTimestamp` to calculate RUM INP, and even if you could it wouldn't necessarily reflect the correct INP since `firstUIEventTimestamp` may not be related to the INP event.",
        "user": "tunetheweb",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987793662,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/1",
        "created_at": "2024-01-29T16:53:30Z",
        "updated_at": "2024-01-29T17:00:34Z",
        "body": "> Should we add a `firstInteractionEventTimestamp`?\r\n\r\n@tunetheweb If this were added (and the what-constitutes-an-interaction logic was consistent between loafs and inp attribution), would mapping a long animation frame to an INP attribution be as simple as `loaf.firstInteractionEventTimestamp === inpAttribution.eventTime`? Or would there be additional considerations?\r\n\r\nIt'd be helpful regardless, as I had to poke around quite a bit to find the issues with `firstUIEventTimestamp` and why it wasn't used in [Noam's linking gist](https://gist.github.com/noamr/316bd48157ab35e4f632a8c2583281b7).",
        "user": "vanderhoop",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987793666,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/1",
        "created_at": "2024-01-29T17:04:23Z",
        "updated_at": "2024-01-29T17:04:23Z",
        "body": "You could in theory have two interactions within the same frame, and the INP could be the second one so might not be the `firstInteractionEventTimestamp`. Or two interactions that start on the same timestamp.\r\n\r\nThough struggling to see how, as presumably the render delay part of INP wouldn't be until the end of the frame so the first one should be the longest... \ud83e\udd14",
        "user": "tunetheweb",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987793670,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/1",
        "created_at": "2024-01-29T21:54:48Z",
        "updated_at": "2024-01-29T21:54:48Z",
        "body": "Hi Barry,We collect LoAF RUM data, and we consider the longest LoAF of the page with firstUIEventTimestamp >0 as the INP of the page.Sent from my iPhoneOn 29 Jan 2024, at 19:04, Barry Pollard ***@***.***> wrote:\ufeff\r\nYou could in theory have two interactions within the same frame, and the INP could be the second one so might not be the firstInteractionEventTimestamp. Or two interactions that start on the same timestamp.\r\nThough struggling to see how, as presumably the render delay part of INP wouldn't be until the end of the frame so the first one should be the longest... \ud83e\udd14\r\n\r\n\u2014Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you were mentioned.Message ID: ***@***.***>",
        "user": "anatdagan",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1987793677,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/1",
        "created_at": "2024-01-30T15:51:57Z",
        "updated_at": "2024-01-30T15:51:57Z",
        "body": "As one thing to consider-- LoAF is used for more than just INP measurement.  Some folks have been using it for Smoothness and a type of \"FPS\" measure.\r\n\r\nIn those cases, `firstUIEventTimestamp` might represent the e.g. pointermove/scroll events.\r\n\r\nI cannot say if the current value is useful or not, but if the issue is INP overlap I think there is a wider discussion about how best to do EventTiming <-> LoAF attribution and we can delay this decision until we gain more experience on this type of attribution work?",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 1997971195,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/10",
        "created_at": "2024-03-14T17:25:40Z",
        "updated_at": "2024-03-14T17:25:40Z",
        "body": "This relates to other discussions, like exposing cold-start for navigations...\r\nIt's a broad issue about adding some entropy dimension to the performance timeline, about slowness/jank that's not actionable by the author.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2025930993,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-03-28T19:15:09Z",
        "updated_at": "2024-03-28T19:15:09Z",
        "body": "New Relic RUM needs some way of informing developers that hook into the LoAF API directly that our wrapper is not the cause of their long animation frames. I was going to look at maybe just overriding the `name` on the function given the wrapped function has a `name` property but this is probably going to cause more issues, especially around stack trace cleansing, even if it does work.\r\n\r\nUltimately, we need a way to direct the developer back to the offending code and I don't think having just a name is sufficient. Even if we could update the name, if the line numbers and file name still point to the RUM provider, developers will still be confused.",
        "user": "patrickhousley",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2036802745,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/11",
        "created_at": "2024-04-04T10:33:10Z",
        "updated_at": "2024-04-04T10:33:10Z",
        "body": "Actually testing this I see that we do get source information for those, what we don't get is source information for e.g. `setTimeout(\"string\")`, not sure what the source information for that should be...",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2135187530,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/13",
        "created_at": "2024-05-28T13:13:14Z",
        "updated_at": "2024-05-28T13:13:14Z",
        "body": "The LoAF source attribution is based on the actual \"entry point\" that is registered with the browser for scheduling, and which is invoked to start this new task / loaf-script, rather than any code that might eventually be called as part of this task.\r\n\r\n- The browser doesn't know you are using React or how React Components use event listeners\r\n- You the developer know that you have a custom event listener defined inside a Component and this is attached a specific element and that this event does the \"interesting bit\" of work. However...\r\n- React happens to [do its own synthetic event dispatch](https://react.dev/reference/react-dom/components/common#react-event-object) (See [caveats](https://react.dev/reference/react-dom/components/common#react-event-object-caveats)) which has some benefits and drawbacks (such as issues like this)\r\n  - Here is one [random article that describes some of the benefits](https://medium.com/@sagnik.das2/what-is-react-synthetic-events-8d7ad766d821)\r\n  - And one [random article that describes some of the drawbacks](https://medium.com/@jessebillard/react-synthetic-events-are-funny-669a25dc103e)\r\n- In the case of LoAF attribution, because react is acting as a \"wrapper\" for your component code, LoAF can only attribute down to the React library.\r\n  - This is also common on pages that use library that wrap all native APIs, e.g. for measurement.\r\n\r\n---\r\n\r\nGenerally, when using frameworks / compilers / bundlers / wrapper libraries... and especially for complex JS-apps using Component style development, it is often the case that the literal source location value returned by LoAF attribution links to a computer generated bundle and with a minified and unreadable name and inconsistent source locations.\r\n\r\nFor that reason, it is expected that you will likely need to rely on source maps (or other lookup methods) to actually show nice developer-readable attribution.  This might require some assistance by frameworks themselves, and LoAF has not be available for very long.  (Though some analytics providers are beginning to offer some of this as a product).\r\n\r\nFor local development, I would say this attribution is expected to be more useful if you use more Vanilla JS approaches to scheduling -- and over time, perhaps JS frameworks will be able to leverage more \"vanilla\" scheduling directly, as the reasons for wrappers are largely historic and for compatibility reasons at this point (and some frameworks already are more vanilla).\r\n\r\n---\r\n\r\nFor attributing INP for a project like yours, I would probably:\r\n\r\n- Use the fact that this is calling into ReactDOM as a signal that this is a Component listener that you explicitly added, rather than some 3p library code / global listeners.\r\n- Instead of using the source location, use the `event.target` from the INP attribtion, as well as the `event.type`.\r\n- Use this information (perhaps from RUM) to find the right UI element (likely testing in lab), then just inspect the DOM (or run a perf profile) to find the long event listener.",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2135196062,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/12",
        "created_at": "2024-05-28T13:17:03Z",
        "updated_at": "2024-05-28T13:17:03Z",
        "body": "Might be related to https://github.com/w3c/long-animation-frames/issues/11",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2136581470,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/13",
        "created_at": "2024-05-29T06:03:26Z",
        "updated_at": "2024-05-29T06:03:26Z",
        "body": "Thanks a tonne for the detailed response @mmocny @tunetheweb over the linked issue! I have been playing around with these metrics and was trying one specific case where some unexpected and interesting metrics were logged, and was hoping to get an insight from you on the same:\r\n\r\nI am currently logging the `interactionTargetElement` node which we get from the attribution data of INP metric (added in v4), alongside this I have a PerformanceObserver which observes for type `long-animation-frame`, to get details about long tasks. The code snippet for the same:\r\n```typescript\r\n\r\n// function logging relevant details to a performance entry\r\n  const analyzePerformanceEntry = (entry) => {\r\n    const { renderStart, firstUIEventTimestamp, blockingDuration, scripts } = entry;\r\n    console.log(`\r\n      Performance Analysis:\r\n      Render Start: ${renderStart}\r\n      First UI Event Timestamp: ${firstUIEventTimestamp}\r\n      Blocking Duration: ${blockingDuration}\r\n      Scripts:\r\n    `);\r\n    scripts.forEach((script) => {\r\n      const { duration, executionStart, sourceURL, sourceFunctionName, invoker, invokerType } = script;\r\n      console.log(`\r\n        Duration: ${duration}\r\n        Execution Start: ${executionStart}\r\n        Source URL: ${sourceURL}\r\n        Source Function: ${sourceFunctionName}\r\n        Invoker: ${invoker}\r\n        Invoker Type: ${invokerType}\r\n      `);\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    const REPORTING_THRESHOLD_MS = 150;\r\n    \r\n// performance observer\r\n    const observer = new PerformanceObserver((list) => {\r\n      for (const entry of list.getEntries()) {\r\n        if (entry.duration > REPORTING_THRESHOLD_MS && (entry as any).firstUIEventTimestamp > 0) {\r\n          console.log(\"Long task detected:\", entry);\r\n          analyzePerformanceEntry(entry);\r\n        }\r\n      }\r\n    });\r\n\r\n    observer.observe({ type: \"long-animation-frame\", buffered: true });\r\n\r\n// callback function to be passed to the `onINP()` method\r\n    const handleINP = (metric) => {\r\n      const { attribution } = metric;\r\n      const { interactionTarget, interactionTargetElement } = attribution;\r\n\r\n      console.log('INP Attribution:');\r\n      console.log(`Interaction Type: ${interactionTarget}`);\r\n      if (interactionTargetElement) {\r\n        const reactPropsKey = Object.keys(interactionTargetElement).find(key => key.startsWith('__reactProps'));\r\n        const reactProps = reactPropsKey ? interactionTargetElement[reactPropsKey] : {};\r\n\r\n        console.log(`\r\n          Interaction Target Element:\r\n          Node Name: ${interactionTargetElement.nodeName}\r\n          Text Content: ${interactionTargetElement.textContent}\r\n          Parent Node Name: ${interactionTargetElement.parentNode?.nodeName}\r\n          Parent Text Content: ${interactionTargetElement.parentNode?.textContent}\r\n          React Props: ${reactProps ? JSON.stringify(reactProps) : 'N/A'}\r\n        `);\r\n      }\r\n    };\r\n\r\n    onINP(handleINP, { reportAllChanges: true });\r\n\r\n    return () => {\r\n      observer.disconnect();\r\n      onINP(null); // Ensure onINP callback is cleaned up\r\n    };\r\n  }, []);\r\n  \r\n// handler for click on button of 3s\r\n   const handleAddItem = () => { \r\n    const newItem = { id: items.length + 1, name: \"\", category: \"\" };\r\n    const start = Date.now();\r\n    while (Date.now() - start < 3000) {}\r\n    setItems([...items, newItem]);\r\n  };\r\n\r\n// handler for click on button of 4s\r\n  const handleAddItem4s = () => {\r\n    const newItem = { id: items.length + 1, name: \"\", category: \"\" };\r\n    const start = Date.now();\r\n    while (Date.now() - start < 4000) {}\r\n    setItems([...items, newItem]);\r\n  };\r\n``` \r\n\r\nI was then testing around with some cases to get results from these logs. The page can be found here: [https://webperf-alpha.vercel.app/dashboard/inp](https://webperf-alpha.vercel.app/dashboard/inp). On loading of this application page on localhost without any CPU Throttling and on Mobile dimensions, I tested for the input: \r\n1. Click on Add Item (4s) button\r\n2. Click on Add Item (3s) button immediately after clicking above\r\n3. Click on Add Item (4s) button again immediately after clicking above.\r\n\r\nThe output behaviour is rather interesting, and I am unable to explain them:\r\nThe first item is added after 4s, the second and third items are loaded together after 7s of the time the first item was loaded. The `interactionTargetElement` shows the 3s button for some reason. There are two doubts here: why is the 2nd and 3rd step above batched together and executed at once (combined delay of 7s?) and why is the target element pointing towards the 3s button and not the 4s button ? The `interactionTarget` docs say:\r\n```\r\n  /**\r\n   * A selector identifying the element that the user first interacted with\r\n   * as part of the frame where the INP candidate interaction occurred.\r\n   * If this value is an empty string, that generally means the element was\r\n   * removed from the DOM after the interaction.\r\n   */\r\n``` \r\n\r\nSo for instance in the case where I first select the 4s button and then immediately click the 3s button, the attribution should point out the element where the interaction started: i.e. the Add Item (4s) button, but it seems the reverse is happening. Am I missing anything here ? An insight into the same would be highly appreciated.\r\n\r\nOutput image:\r\n<img width=\"1791\" alt=\"Screenshot 2024-05-29 at 1 57 05\u202fAM\" src=\"https://github.com/w3c/long-animation-frames/assets/171024309/1cd73ce1-ef87-4e20-908d-dc1db12b45b0\">\r\n",
        "user": "jinja12",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2136852650,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/13",
        "created_at": "2024-05-29T08:35:13Z",
        "updated_at": "2024-05-29T08:35:13Z",
        "body": "I think I figured out the reason the performance metrics are reported together for the 2nd and the 3rd click: it is due to React batching the updates together, hence the metrics for the 2nd and 3rd click log together at once. I tested this logic for another case with 4 clicks, the last 3 updates are batched here again. So that is due to the latest React features, but again the doubt of which `interactionTargetElement` will be reported in such scenarios still stand, the perceived output is different from the expected one as specified in the docs. ",
        "user": "jinja12",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2136875096,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/13",
        "created_at": "2024-05-29T08:45:41Z",
        "updated_at": "2024-05-29T08:45:41Z",
        "body": "> alongside this I have a PerformanceObserver which observes for type long-animation-frame, to get details about long tasks. \r\n\r\nv4 includes any long tasks overlapping the INP event in the INP callback to save you having to monitor that separately.\r\n\r\nBut it can be good to measure all LoAFs to also get long task outside the immediate INP event.\r\n\r\n> I think I figured out the reason the performance metrics are reported together for the 2nd and the 3rd click: it is due to React batching the updates together, hence the metrics for the 2nd and 3rd click log together at once. I tested this logic for another case with 4 clicks, the last 3 updates are batched here again. So that is due to the latest React features, but again the doubt of which interactionTargetElement will be reported in such scenarios still stand, the perceived output is different from the expected one as specified in the docs.\r\n\r\nOK that's interesting. I would guess React is trying it's best to be responsive to the first click, but then batching the rest together to save having to do multiple layouts together?\r\n\r\nGoing  back to the docs:\r\n\r\n```js\r\n   /**\r\n   * A selector identifying the element that the user first interacted with\r\n   * as part of the frame where the INP candidate interaction occurred.\r\n   * If this value is an empty string, that generally means the element was\r\n   * removed from the DOM after the interaction.\r\n   */\r\n```\r\n\r\nIt would seem, that in that example, there would be two frames\u2014the first with click 1, and the second with the remaining clicks that React has batched together.\r\n\r\nIn that case the frame with the longest one will be the \"INP frame\". All else being equal this would be the second frame (as it includes multiple clicks so will take multiple processing times to finish). And this is what you are seeing. The `interactionTarget` is set to the first interaction of the INP frame. The prior frame may well have been quite slow, but the subsequent one was slower still. Now I know you're running this with `reportAllChanges: true` but if all the Event Timings are reported together (as could often be the case in cases like this where the main thread is busy), then they will be processed together, but split into frames, so only the second one would be emitted as an INP event.\r\n \r\nSo I think the docs (and the implementation!) are right in this case. But certainly a confusing one if you're not aware how this all works!",
        "user": "tunetheweb",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2136927207,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/13",
        "created_at": "2024-05-29T09:11:09Z",
        "updated_at": "2024-05-29T09:11:09Z",
        "body": "> OK that's interesting. I would guess React is trying it's best to be responsive to the first click, but then batching the rest together to save having to do multiple layouts together?\r\n\r\nYep exactly! I was not sure if we would should view this as separate frames (even if so how exactly though): one for the first click and the second for all the subsequent clicks. This logics fits perfectly and makes sense, checked on the following case of immediate clicks one after the another:\r\n1. 3s button\r\n2. 3s button\r\n3. 4s button\r\n4. 4s button\r\n\r\nThe `interactionTargetElement` is indeed reported as the 3s button (starting interaction of the 2nd frame). \r\nThanks for the clarification :)\r\n\r\n",
        "user": "jinja12",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2136940006,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/13",
        "created_at": "2024-05-29T09:17:31Z",
        "updated_at": "2024-05-29T09:17:31Z",
        "body": "> I was not sure if we would should view this as separate frames (even if so how exactly though)\r\n\r\nIf you look at Event Timing entries I'd expect the first to finish (starttime + duration) at time 1, and the rest all at the same time 2 (or close enough minus some rounding and limits!), since the \"starttime + duration\" is approximately the frame paint time (rather than the end of event handler processing).\r\n\r\nShould also be able to see in a performance trace.",
        "user": "tunetheweb",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2136969621,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/13",
        "created_at": "2024-05-29T09:32:23Z",
        "updated_at": "2024-05-29T09:32:23Z",
        "body": "Right, will see once with a performance trace as well.",
        "user": "jinja12",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2137155561,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/13",
        "created_at": "2024-05-29T11:11:23Z",
        "updated_at": "2024-05-31T14:40:00Z",
        "body": "OK so tried this.\r\n\r\n**Desktop**\r\n\r\nWhen I do this:\r\n- Click on Add Item (4s) button\r\n- Click on Add Item (3s) button immediately after clicking above\r\n- Click on Add Item (4s) button again immediately after clicking above.\r\n\r\nI see this:\r\n- All 3 items are rendered together\r\n- The INP target is the 4s click element\r\n\r\n<img width=\"1484\" alt=\"image\" src=\"https://github.com/w3c/long-animation-frames/assets/10931297/2c62b35b-b357-4ea3-b18e-a2dcfb1113f6\">\r\n\r\n- The trace shows they were indeed split into two tasks, but both were rendered together, hence why the first interaction was the longest one from INP point of view.\r\n\r\n<img width=\"800\" alt=\"image\" src=\"https://github.com/w3c/long-animation-frames/assets/10931297/9792891a-3643-446b-8a7d-bf9e1e55454a\">\r\n\r\n**Mobile**\r\n\r\nWhen enabling mobile emulation and repeating, it's slightly different:\r\n\r\n- Two INP events are emitted, with the second being much longer (due to being delayed by the first), and overtaking the first. This second one is therefore the ultimate INP for the page. The first INP target is the 4s button, the second is the 3s button:\r\n\r\n<img width=\"774\" alt=\"image\" src=\"https://github.com/w3c/long-animation-frames/assets/10931297/157a41cf-e96c-4244-b55e-7b09ba0399b5\">\r\n\r\nThe trace shows two distinct interactions:\r\n\r\n<img width=\"733\" alt=\"image\" src=\"https://github.com/w3c/long-animation-frames/assets/10931297/5da817fa-5c46-49c1-9e5b-d02ea89c37ba\">\r\n\r\nWeirdly the screenshot do not show two step render, but that's what I saw with my own eyes, and if you zoom in there is a paint and a commit between the two confirming a render happened then:\r\n\r\n<img width=\"249\" alt=\"image\" src=\"https://github.com/w3c/long-animation-frames/assets/10931297/0ea37fde-aa64-42b7-8128-66730005a5b6\">\r\n\r\nSo it looks like on mobile Chrome prefers the early, separate paint, but on desktop it decides to wait and do them both together. Chrome does all sorts of heuristics to decide when to render a frame, especially when it knows there are more inputs to process, and it looks like the mobile and desktop heuristics are slightly different. Maybe @mmocny can explain why?\r\n\r\n",
        "user": "tunetheweb",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2142366987,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/13",
        "created_at": "2024-05-31T14:29:55Z",
        "updated_at": "2024-05-31T14:33:19Z",
        "body": "At the start of a `BeginMainFrame` task (i.e. rendering) Chrome will *flush all UI events* which are *already queued in the event loop* at the start of BMF, but won't flush any that are added during the BMF.\r\n\r\nTherefore, if your first interaction is so long running that you have time to interact again, before BMF starts *and the browser process actually sends these events to renderer in time*, then you will effectively cluster those inputs into a single long animation frame.\r\n\r\nI don't think the scheduling policy is any different on desktop or mobile-- but what changes is that as we change input types, we change how we send events from browser to renderer.\r\n\r\nTouch is weirder than mouse input-- and DevTools touch emulation is weirdest of all.  Sometimes you have to wait for Renderer to acknowledge feedback from previous events (i.e. IPC messages that start after processingEnd), and before browser can send new IPC about future events...\r\n\r\n---\r\n\r\nIn this case these were distinct interactions, so I had expected it would work.  I tried myself locally and could repro as Barry says.  It wasn't just luck / races.\r\n\r\nI traced with Perfetto and here is what I see:\r\n\r\n1. Indeed, the second and third events are stuck in browser process waiting for the first event to finish:\r\n\r\n![Screenshot 2024-05-31 at 10 14 58](https://github.com/w3c/long-animation-frames/assets/474282/79248419-a34d-46a9-bc6f-154bd5501eee)\r\n\r\nThe 'flow' shows when the browser received the event and forwarded it to the renderer.  You should see that it is first started after the first interactions ends-- weird, I definitely interacted earlier!\r\n\r\n\r\n2. If I follow that flow to the begging I see references to `RenderWidgetHostInputEventRouter::ForwardEmulatedGestureEvent`, and I can find another flow event:\r\n\r\n![Screenshot 2024-05-31 at 10 14 47](https://github.com/w3c/long-animation-frames/assets/474282/02df15a4-aba3-43de-9304-0eb73631018c)\r\n\r\nFollowing that flow to its start, I find the original `RenderWidgetHostViewCocoa::mouseEvent`.\r\n\r\nLooks like the way Touch emulation works is:\r\n- Browser receives mouse events, sends to renderer\r\n- Renderer has to schedule the mouse events, before it can \"reject them\" and ask for touch simulation instead\r\n- Goes back to Browser and back to renderer.\r\n\r\nAll this means that we are guaranteed to have a few process IPC between the end of the first interaction event and the start of BMF task and that is a very narrow window to race and rendering will win.\r\n\r\n---\r\n\r\nNet/net, don't rely on mobile emulation for very detailed scheduling test :D\r\n\r\nAlso -- more generally -- I have been [advocating to make some scheduling changes to this scheduling policy](https://issues.chromium.org/issues/338037072), so I wouldn't rely on it too heavily.\r\n\r\nOther browsers are already different.  The mobile emulated behaviour today is likely to match the future behaviour more if I was to guess.",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2144283217,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/13",
        "created_at": "2024-06-03T04:59:48Z",
        "updated_at": "2024-06-03T04:59:48Z",
        "body": "Got it, thanks a lot for the detailed explanation! ",
        "user": "jinja12",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2158910590,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/12",
        "created_at": "2024-06-10T17:20:42Z",
        "updated_at": "2024-06-10T17:20:42Z",
        "body": "Requesting to review this once (@mmocny @tunetheweb @noamr), the current LoAF entries obtained from a simple PerformanceObserver observing for Long Animation Frames like:\r\n```typescript\r\n    const REPORTING_THRESHOLD_MS = 150;\r\n    const observer = new PerformanceObserver((list) => {\r\n      for (const entry of list.getEntries()) {\r\n        if (\r\n          entry.duration > REPORTING_THRESHOLD_MS &&\r\n          (entry as any).firstUIEventTimestamp > 0\r\n        ) {\r\n          console.log(\"Long task detected:\", entry)\r\n          analyzePerformanceEntry(entry);\r\n        }\r\n      }\r\n    });\r\n\r\n    observer.observe({ type: \"long-animation-frame\", buffered: true });\r\n``` \r\n\r\nTo get something more actionable, if we could get the exact function (name) delaying the main thread it would be best (case where we automating this process of finding action items. The sourceFunctionName and sourceURL are not really helpful when working with a bundled code (eg: like in ReactJS, NextJS). Is there a way to get more insights into the same apart from the above so that finding actionable items is easier ? I am aware of the method specified here: \"[https://github.com/w3c/long-animation-frames/issues/3#issuecomment-1987796069](https://github.com/w3c/long-animation-frames/issues/3#issuecomment-1987796069)\" , but something more useful in scenarios such as above would be nice. Continuation of Issue: [https://github.com/w3c/long-animation-frames/issues/3](https://github.com/w3c/long-animation-frames/issues/3)",
        "user": "jinja12",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2158916412,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/12",
        "created_at": "2024-06-10T17:24:20Z",
        "updated_at": "2024-06-10T17:24:20Z",
        "body": "@jinja12 that seems directly related to #3 as you mention, rather than the issue @rackaam raised here?",
        "user": "tunetheweb",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2158952596,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/12",
        "created_at": "2024-06-10T17:45:43Z",
        "updated_at": "2024-06-10T17:45:43Z",
        "body": "Yeah, I added it here since I too want to get more information regarding the entry point of the function responsible for the long task blocking (not specific to setTimeout)",
        "user": "jinja12",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2158994498,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/12",
        "created_at": "2024-06-10T18:09:21Z",
        "updated_at": "2024-06-10T18:09:21Z",
        "body": "This is more related to #11 than to #3. It's most likely `setTimeout(code_as_string, timeout)` and `xhr.onreadystatechange = handler_as_string`, both of which don't have an obvious source location. We can perhaps provide an elided version of the source code itself, or an md5 digest?",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2159006932,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/12",
        "created_at": "2024-06-10T18:16:12Z",
        "updated_at": "2024-06-10T18:20:27Z",
        "body": "Right, is there an existing way to get the source location of the function calling the long task in bundled packages in cases excluding the one you mention? For example:\r\n```typescript\r\nfunction blockMainThread(duration: number) {\r\n    const start = Date.now();\r\n    while (Date.now() - start < duration) {\r\n      // Busy-wait loop to block the main thread\r\n    }\r\n}\r\n\r\n// A simple form embedded on a page, which when submitted triggers a 3s main thread block\r\nconst form = document.getElementById('testForm');\r\n\r\nform.onsubmit = (event) => {\r\n  event.preventDefault();\r\n  blockMainThread(3000); // 3-second blocking operation\r\n};\r\n```",
        "user": "jinja12",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2159118326,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/12",
        "created_at": "2024-06-10T19:18:04Z",
        "updated_at": "2024-06-10T19:18:04Z",
        "body": "> Right, is there an existing way to get the source location of the function calling the long task in bundled packages in cases excluding the one you mention? For example:\r\n> \r\n> ```ts\r\n> function blockMainThread(duration: number) {\r\n>     const start = Date.now();\r\n>     while (Date.now() - start < duration) {\r\n>       // Busy-wait loop to block the main thread\r\n>     }\r\n> }\r\n> \r\n> // A simple form embedded on a page, which when submitted triggers a 3s main thread block\r\n> const form = document.getElementById('testForm');\r\n> \r\n> form.onsubmit = (event) => {\r\n>   event.preventDefault();\r\n>   blockMainThread(3000); // 3-second blocking operation\r\n> };\r\n> ```\r\n\r\nIn this case `sourceLocation` would give you the location of the arrow function you passed to `onsubmit`. There is no existing low-overhead way to give you the source location of `blockMainThread`, as that would require a full stack trace which is a very heavy operation, but as per #11 you can wrap it in user timing and perhaps we can at some point provide some mechanism for conditional user-timing or special function annotation for this purpose.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2164215990,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/14",
        "created_at": "2024-06-13T02:06:46Z",
        "updated_at": "2024-06-13T02:06:46Z",
        "body": "LoAF does fall back to reporting just \"long task\", and as you note in the demo, the first key interaction does report a LoAF.\r\n\r\nI don't think this has anything to do with paints.  For some reason the second long task isn't reported.",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2164976440,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/14",
        "created_at": "2024-06-13T08:25:09Z",
        "updated_at": "2024-06-13T10:25:28Z",
        "body": "OK sounds like a Chromium Bug so raised this: https://issues.chromium.org/issues/346918311\r\n\r\n> LoAF does fall back to reporting just \"long task\"\r\n\r\nIs this explicitly documented anywhere in the spec? Can't see it. Should it be?",
        "user": "tunetheweb",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2165771712,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/14",
        "created_at": "2024-06-13T14:03:24Z",
        "updated_at": "2024-06-13T14:03:24Z",
        "body": "The second paragraph of the intro in this repo:\r\n\r\n> Long animation frames (LoAF), as a revamp of longtasks, aim to assist with that: a LoAF is an indication that at a particular point in time, the browser was congested, in such a way that it took a long time from the beginning of a task until updating the rendering **(or until the point where it was clear that no render was necessary)**.\r\n\r\n(emphasis mine)\r\n\r\nThen the section that [introduces LoAF](https://github.com/w3c/long-animation-frames?tab=readme-ov-file#introducing-loaf) says:\r\n\r\n> It's the time measured between when the main thread started doing any work (see startTime [here](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)), until it is either [ready to paint](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model:mark-paint-timing) or idle (has nothing to do).\r\n\r\nAnd of course, its well specced:\r\n\r\n* This [english-language paragraph summarizes](https://w3c.github.io/long-animation-frames/#loaf-vs-longtasks)\r\n* I think [this bit](https://w3c.github.io/long-animation-frames/#record-task-end-time) step 6 is it:\r\n\r\n> If the user agent believes that updating the rendering of document\u2019s [node navigable](https://html.spec.whatwg.org/multipage/document-sequences.html#node-navigable) would have no visible effect, then [report frame timing](https://w3c.github.io/long-animation-frames/#report-frame-timing) given document and return.",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2165838404,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/14",
        "created_at": "2024-06-13T14:27:04Z",
        "updated_at": "2024-06-13T14:27:04Z",
        "body": "I just did some test in Canary and found that when this symptom happens, all of LoAF measurement is not working at all-- even for tracing.\r\n\r\nSo, it's not that LoAF is choosing not to emit a performance entry, its that we are failing to observe LoAF durations.\r\n\r\nI'll have to run a custom build to see what animation frame timing monitor is observing here.  (e.g. are we still observing tasks but for some reason the attribution is getting accumulated forever without flushing?  Do we stop observing?  Is the monitor destroyed/detached?)",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2195416238,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/16",
        "created_at": "2024-06-27T18:25:12Z",
        "updated_at": "2024-06-27T18:25:12Z",
        "body": "I agree that this would be a lot more convenient for developers to see line/column instead of char position.  In an earlier prototype that is actually how it worked.\r\n\r\nHowever-- Noam noticed that this was a perf regression, because it requires parsing the text (in order to find all the newline characters).  This isn't something that happens typically and so it is expensive to do automatically.\r\n\r\n---\r\n\r\nI wonder if it could be possible to request this type of parsing explicitly, after the LoAF fires, only once we know there is a client that is interested?",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2196792582,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/16",
        "created_at": "2024-06-28T12:24:07Z",
        "updated_at": "2024-06-28T12:24:07Z",
        "body": "Thanks for the reply!\r\n\r\nFor more context, I'm sending the LoAF to an observability tool for later use and I'm trying to link the sourceCharPosition to the matching development file.\r\nAgreed that natively paying that cost for every LoAF is probably not great. A way to opt-in to it would be a good alternative.\r\n\r\nI tried to replicate this in user space by using `fetch` and `only-if-cached` request in order to retrieve the source file content if it exists in the browser cache. I then compute the `sourceLine` and `sourceColumn` from the `sourceCharPosition` provided by the LoAF and it seems to work well.\r\n\r\nHowever it would be even better with the opt-in API you're suggesting.",
        "user": "Miz85",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2197229669,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/16",
        "created_at": "2024-06-28T15:59:35Z",
        "updated_at": "2024-06-28T15:59:35Z",
        "body": "Oh that's a neat strategy to just polyfill on client.  Neat!  I might use\r\nthat!\r\n\r\nI suspect that many scripts are dynamically rendered per request, and/or\r\nminified, and require source mapping (not just to the UN minified file but\r\nalso to original source templates) and this seems best done server side,\r\nanyway.\r\n\r\nIf the script is static, then char position should be sufficient to do the\r\nline mapping on server as well.\r\n\r\nIt's neat to do on client, but I suspect there aren't many cases where it's\r\nactually better, except for local debugging use cases.\r\n\r\nNot sure though-- is there a use case where doing it on client is\r\nspecifically enabling? Ignoring just developer ergonomics?\r\n\r\nOn Fri, Jun 28, 2024, 08:24 Nazim Saouli ***@***.***> wrote:\r\n\r\n> Thanks for the reply!\r\n>\r\n> For more context, I'm sending the LoAF to an observability tool for later\r\n> use and I'm trying to link the sourceCharPosition to the matching\r\n> development file.\r\n> Agreed that natively paying that cost for every LoAF is probably not\r\n> great. A way to opt-in to it would be a good alternative.\r\n>\r\n> I tried to replicate this in user space by using fetch and only-if-cached\r\n> request in order to retrieve the source file content if it exists in the\r\n> browser cache. I then compute the sourceLine and sourceColumn from the\r\n> sourceCharPosition provided by the LoAF and it seems to work well.\r\n>\r\n> However it would be even better with the opt-in API you're suggesting.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/w3c/long-animation-frames/issues/16#issuecomment-2196792582>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AADTZKQ4FVJIVZVHCGQDXC3ZJVIX3AVCNFSM6AAAAABJ53I4OSVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDCOJWG44TENJYGI>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2198219944,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/16",
        "created_at": "2024-06-29T14:51:29Z",
        "updated_at": "2024-06-29T14:51:29Z",
        "body": "yes you're absolutely right! However I'm working on an observability tool and I want to collect LoAFs for our users and link to their source code automatically.\r\n\r\nSo my constraints are:\r\n- I don't have access to the minified file on the server side\r\n- I do have access to source maps because users have a way to send them to us through an API\r\n\r\nThis is why I did that way. However it's good enough for a POC but I'm probably gonna hit CORS issues. If the opt-in API you were suggesting existed, I could let our users opt-in to that computation and accept the performance hit as a trade off to being able to monitor LoAFs.",
        "user": "Miz85",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2208455290,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/16",
        "created_at": "2024-07-04T08:54:41Z",
        "updated_at": "2024-07-04T08:54:41Z",
        "body": "@mmocny Coming back to your idea about performing the parsing only once we know there is a client that is interested. What would be a good way to advocate for that and see if it could actually get included down the line?",
        "user": "Miz85",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2209163877,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/16",
        "created_at": "2024-07-04T14:47:35Z",
        "updated_at": "2024-07-04T14:47:35Z",
        "body": "I think you just did :P\r\n\r\n@noamr for thoughts.",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2209178668,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/16",
        "created_at": "2024-07-04T14:55:42Z",
        "updated_at": "2024-07-04T14:55:42Z",
        "body": "I think this is better done in a service-worker than in the browser... Put the service worker between the document and the server that gives you the script, and tee the response stream to some processor that returns an array of line breaks. It should be trivial to create a `get_line_and_col(source_char_position, array_of_line_breaks)` function based on a similar function in chromium code.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2214333426,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/16",
        "created_at": "2024-07-08T14:55:02Z",
        "updated_at": "2024-07-08T14:55:02Z",
        "body": "Hey @noamr, thank you so much for your reply!  Alright, sounds like a good path forward I'm going to give it a shot.",
        "user": "Miz85",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2223146756,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-11T14:52:27Z",
        "updated_at": "2024-07-11T14:52:27Z",
        "body": "Coming back to this, I think a potential way to address this is an additional attribute in {mark|measure}Options that helps filter user timing entries, with one of the options being to include those entries in the buffer only if they contribute to a LoAF (or a LoAF long-script).\r\n\r\nSo a library like NewRelic as mentioned in https://github.com/w3c/long-animation-frames/issues/3#issuecomment-2025930993 could wrap the user's function with `performance.measure(\"user-function\", {filter: \"long-animation-frame\"})` (strawman) and then it would be a much better insight than just the entry point.\r\n\r\n",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2225797941,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-12T15:10:56Z",
        "updated_at": "2024-07-12T15:13:55Z",
        "body": "> with one of the options being to include those entries in the buffer only if they contribute to a LoAF (or a LoAF long-script).\r\n\r\nIt seems to me like you would have to buffer these at first, then clean up these marks and measures afterwards.\r\n\r\nToday, there is no limit to the number of marks/measures in the buffer, so overflow is not really a problem (unless so many are issued that we get into overall memory usage worries).\r\n\r\nI think that means that: just adding marks/measures, leaving them there, then filtering manually, might be sufficient?\r\n\r\nWhat about just a `getEntriesBy*` variant that accepts both a `type` and also a time range (and optionally that this time range can be specified by passing another `entry`)?\r\n\r\nThe usage would be something like:\r\n\r\n- Create a PerformanceObserver for LoAF\r\n- From each LoAF entry observed, ask for the marks/measures that overlap its timing",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2225806222,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-12T15:15:24Z",
        "updated_at": "2024-07-12T15:15:24Z",
        "body": "As per your original proposal, Related questions:\r\n\r\n- It seems not so common to me to have active PerformanceObservers for marks/measures, but if someone did have one, would we want to report these LoAF-only entries?\r\n- If we did, would we delay adding these entries into the timeline until after we know if a LoAF happened (i.e. a separate buffer)?\r\n- If we did that, would we wait only until we know a LoAF is being measured, or wait for the LoAF is done measuring (i.e. LoAF always reported first)?",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2225813923,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-12T15:19:30Z",
        "updated_at": "2024-07-12T15:19:30Z",
        "body": "Also also, there have been requests to add groups/categories/labels to User Timings multiple times for multiple purposes.  I wonder if this really needs to be LoAF specific or if it could just be a generic feature like that?  Then library authors could use as they see fit and might be more creative that we are here?\r\n\r\nI guess the question I would have is: is it likely that a library like NewRelic would want to consume marks/measures that were created by a different app/library or just their own?  Would NewRelic want to share annotations that would be useful to consume by others?  (Such that a common standard us useful?)",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2225870026,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-12T15:51:54Z",
        "updated_at": "2024-07-12T15:51:54Z",
        "body": "cc @and-oli (maybe some overlap with DevTools extensibility)",
        "user": "rviscomi",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2225953206,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-12T16:47:18Z",
        "updated_at": "2024-07-12T16:47:18Z",
        "body": "> > with one of the options being to include those entries in the buffer only if they contribute to a LoAF (or a LoAF long-script).\r\n> \r\n> It seems to me like you would have to buffer these at first, then clean up these marks and measures afterwards.\r\n\r\nRight\r\n\r\n> \r\n> Today, there is no limit to the number of marks/measures in the buffer, so overflow is not really a problem (unless so many are issued that we get into overall memory usage worries).\r\n> \r\n> I think that means that: just adding marks/measures, leaving them there, then filtering manually, might be sufficient?\r\n\r\nIt's suboptimal in terms of both efficiency and ergonomics. By doing this we're encouraging people to potentially add a massive amount of events to the buffer and these memory (and lookup efficiency) problems can potentially explode. It also adds a lot of noise to the performance timeline and to traces.\r\n\r\n> \r\n> What about just a `getEntriesBy*` variant that accepts both a `type` and also a time range (and optionally that this time range can be specified by passing another `entry`)?\r\n> \r\n> The usage would be something like:\r\n> \r\n> * Create a PerformanceObserver for LoAF\r\n> * From each LoAF entry observed, ask for the marks/measures that overlap its timing\r\n\r\nSee above\r\n\r\n> As per your original proposal, Related questions:\r\n> \r\n> * It seems not so common to me to have active PerformanceObservers for marks/measures, but if someone did have one, would we want to report these LoAF-only entries?\r\n\r\nI think not, perhaps attach them to the `loaf.scripts` entry?\r\n\r\n> * If we did, would we delay adding these entries into the timeline until after we know if a LoAF happened (i.e. a separate buffer)?\r\n\r\nYea definitely.\r\n\r\n> * If we did that, would we wait only until we know a LoAF is being measured, or wait for the LoAF is done measuring (i.e. LoAF always reported first)?\r\n\r\nPerhaps in the same callback, as in if you observe both types you'd get them concurrently? Otherwise in `PerformanceScriptEntry` which is perhaps more suitable.\r\n\r\n> Also also, there have been requests to add groups/categories/labels to User Timings multiple times for multiple purposes. I wonder if this really needs to be LoAF specific or if it could just be a generic feature like that? Then library authors could use as they see fit and might be more creative that we are here?\r\n\r\nI don't think this is related. One is arbitrary metadata and the other is a capturing condition.\r\n\r\n> \r\n> I guess the question I would have is: is it likely that a library like NewRelic would want to consume marks/measures that were created by a different app/library or just their own? Would NewRelic want to share annotations that would be useful to consume by others? (Such that a common standard us useful?)\r\n\r\nI feel that those are parallel question.\r\nNewRelic can use mark/measure names or new metadata we define to filter out what they care about, but that won't help with exploding the buffer with LoAF-attribution-tracing.\r\n\r\nAn additional thing I would propose for this type of mark/measure is that you can't mark/measure it before/after the fact, as in the timestamp has to be now or at least within the current script entry.\r\n\r\n",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2225961981,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-12T16:53:12Z",
        "updated_at": "2024-07-12T16:53:28Z",
        "body": "All of that makes sense in isolation, it just feels needlessly coupled to LoAF data.\r\n\r\nWhat if I wanted to review these marks when they overlap with an Event Timing (but didn't trigger LoAF specifically because delays are from after-main-presentation)",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2225968333,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-12T16:57:34Z",
        "updated_at": "2024-07-12T16:57:34Z",
        "body": "> All of that makes sense in isolation, it just feels needlessly coupled to LoAF data.\r\n> \r\n> What if I wanted to review these marks when they overlap with an Event Timing (but didn't trigger LoAF specifically because delays are from after-main-presentation)\r\n\r\nI agree, I think the API should be attachable to any platform entry type where it makes sense, not coupled with LoAF specificially, or at least written in a way that's extendable to do that.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2225988018,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-12T17:09:21Z",
        "updated_at": "2024-07-12T17:09:21Z",
        "body": "Can we evolve your proposal slightly to something like this, then?\r\n\r\n- performance.mark / measure merely supports `buffered:false`, or something like it, rather than explicitly listing the type of entry to pair with.\r\n  - This has also been independently requested.\r\n  - it seems some of the performance issues with User Timings is around the need to clone various data (like `details`) in order to persist on the timeline.  But several use cases don't need that feature and only conditionally observe.\r\n- PerformanceObserver supports `{ observeUserTimings: true }` or even `{ type: 'entry-type', observeNestedType: 'other-entry-type' }`, or something like it.\r\n  - This becomes like a temporary nested observer which is only observes the nested type when the main entry type is actively being observed.\r\n  - Perhaps instead of `list.getEntries()` you would need to `list.getNestedEntries()`\r\n\r\n(Wonder if this would be useful to e.g. measure all Event Timings and then only nested LoAF entries, and then only nested user timings of those...)",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2226238225,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-12T19:34:18Z",
        "updated_at": "2024-07-12T19:37:18Z",
        "body": "> Can we evolve your proposal slightly to something like this, then?\r\n> \r\n> * performance.mark / measure merely supports `buffered:false`, or something like it, rather than explicitly listing the type of entry to pair with.\r\n>   \r\n>   * This has also been independently requested.\r\n>   * it seems some of the performance issues with User Timings is around the need to clone various data (like `details`) in order to persist on the timeline.  But several use cases don't need that feature and only conditionally observe.\r\n> * PerformanceObserver supports `{ observeUserTimings: true }` or even `{ type: 'entry-type', observeNestedType: 'other-entry-type' }`, or something like it.\r\n>   \r\n>   * This becomes like a temporary nested observer which is only observes the nested type when the main entry type is actively being observed.\r\n>   * Perhaps instead of `list.getEntries()` you would need to `list.getNestedEntries()`\r\n> \r\n> (Wonder if this would be useful to e.g. measure all Event Timings and then only nested LoAF entries, and then only nested user timings of those...)\r\n\r\nRiffing on that, perhaps if we add `{ buffered: false }`, we can do the trick where if you have an observer that's registered to both LoAF (or event-timing) and user-timing, the user timing entries would be buffered to the LoAF, and the LoAF would be buffered to the event-timing entry if applicable, and the `entries` object in the callback would have some utility functions to correlate, and call it a day?\r\n\r\n```js\r\n// in your function\r\nperformance.mark(functionName, { buffered: false });\r\n\r\n// the observer\r\nconst observer = new Performance Observer(entries => {\r\n  const [loaf] = entries.getEntriesByType(\"long-animation-frame\");\r\n  const [script] = loaf.scripts;\r\n  const marks = entries.getOverlappingEntries(script, {type: \"mark\" });\r\n});\r\nobserver.observe({type: \"long-animation-frame\"});\r\nobserver.observe({type: \"mark\" });\r\n```",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2226517588,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-12T23:21:07Z",
        "updated_at": "2024-07-12T23:21:07Z",
        "body": "I like that!\r\n\r\n---\r\n\r\nRegarding `{ buffered: false }` I think that might have been a bad suggestion in hindsight.\r\n\r\n1. You would still pay the performance cost of creating the entry for this use case, even if lifetime is short, and even if it's a convenient way to manage cleanup\r\n2. By not buffering at all, it motivates developers to load PO's eagerly, which we don't want to motivate\r\n3. A normal PO for just \"mark\" types I guess would see all the marks in real time.  I know I said PO's for marks aren't as common, but that might still be undesired here.\r\n\r\nI think we need to go back to the idea of this mark type being detached from the typical perf timeline, yet still allow limited buffering (Perhaps more constrained than typical user timings).",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2228407466,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-15T12:37:51Z",
        "updated_at": "2024-07-15T12:37:51Z",
        "body": "Reciting internal conversation with @mmocny: I feel that turning this into a generic user-timing function has enough limitations to make it suboptimal:\r\n- It's hard to do efficiently without clobbering existing receivers of user-timing or creating new GCed objects\r\n- It loses information about the function we want to trace, such as its source location.\r\n\r\nSo instead, I propose to go back to the original more narrow-scoped proposal, to annotate functions for use in LoAF:\r\n```js\r\nfunction addEventListenerWithWrapper(event_type, internal_function) {\r\n   const wrapped_internal_function = performance.bind(internal_function);\r\n   addEventListener(event_type, wrapped_internal_function);\r\n}\r\n```\r\n\r\nWhere `performance.bind` will have the exact signature of `Function.prototype.bind` but would wrap the internal function in measuring monotonic timestamps (`performance.now()`), and if the result is >5ms this function would appear in LoAF as a long script.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2228457461,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-15T13:03:46Z",
        "updated_at": "2024-07-15T13:03:46Z",
        "body": "Will there be a mechanism to provide a user-defined name, or will it use `function.name`?\r\n",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2228536472,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-15T13:41:22Z",
        "updated_at": "2024-07-15T13:41:22Z",
        "body": "> Will there be a mechanism to provide a user-defined name, or will it use `function.name`?\r\n\r\nI think we can do that but then we can't use additional arguments for `bind`. Perhaps that's ok",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2238528101,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-19T07:15:06Z",
        "updated_at": "2024-07-19T07:15:06Z",
        "body": "Summarizing WG discussion:\r\n- There is a big ask for this, some people avoid using LoAF because of this issue.\r\n- The issue is split into two:\r\n  (1) attribution: with wrapper functions it seems like \"it's the wrapper's fault that this script is long\"\r\n  (2) diagnostics: a script entry point is not always granular enough.\r\n- In addition, people were complaining about lack of support for source-maps in LoAF and that that constraints the usefulness of source location.\r\n\r\nFor (1), we need something reliable like function wrapping, as custom marks/measures don't give source location.\r\nFor (2), something like a low-overhead mark/measure that ties to particular entries is perhaps preferable as not everything is a \"long function\".",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2238550189,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/3",
        "created_at": "2024-07-19T07:30:17Z",
        "updated_at": "2024-07-19T07:30:39Z",
        "body": "A shape that came to mind:\r\n\r\n```js\r\n// entryTypes can be LoAF, event, measure, script\r\nconst tracing = new PerformanceTracing({threshold, entryTypes, detail})\r\n\r\n// This adds a mark/measure that gets applied to overlapping entries\r\n// from the given list\r\ntracing.mark(label);\r\ntracing.measure(label);\r\n\r\n// This creates a bound function that reports the labeled trace,\r\n// and also appears as a `PerformanceScriptTiming` entry in LoAF\r\ntracing.bind(wrapped_function, label)\r\n\r\nPerformance{User|LongAnimationFrame|Script|Event}Timing.traces\r\n    PerformanceTraceEntry (start, duration, name, detail)\r\n```\r\n\r\nThe advantage of creating a `PerformanceTracing` object or some such in advance is that we don't incur the overhead of creating options dictionaries every time we trace.\r\n",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2245347487,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/11",
        "created_at": "2024-07-23T14:02:22Z",
        "updated_at": "2024-07-23T14:02:22Z",
        "body": "Would be great to log id / data-attribute / something else for inline scripts. We have a lot of inline script inside our page, and loaf entries for them are useless.",
        "user": "proofyman",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2271663914,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/17",
        "created_at": "2024-08-06T16:16:01Z",
        "updated_at": "2024-08-06T16:16:01Z",
        "body": "I think that the `setTimeout` is expected to be 0 here, and the `event-listener` is expected to be non-0 here (assuming you called `alert()` directly from the event listener)",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2271669547,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/17",
        "created_at": "2024-08-06T16:19:09Z",
        "updated_at": "2024-08-06T16:19:09Z",
        "body": "That's right, here's the button source:\r\n\r\n```html\r\n<button onclick=\"alert('This no longer blocks INP as of Chrome 127! \ud83c\udf89')\">\r\n  Alert\r\n</button>\r\n```",
        "user": "rviscomi",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2271694693,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/17",
        "created_at": "2024-08-06T16:32:26Z",
        "updated_at": "2024-08-06T16:32:26Z",
        "body": "Ah, I know there are some oddities with inline scripts and LoAF.  If you changed to use `addEventListener` would it be any different?",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2271705764,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/17",
        "created_at": "2024-08-06T16:38:57Z",
        "updated_at": "2024-08-06T16:38:57Z",
        "body": "Updated:\r\n\r\n```js\r\nloafAlert.addEventListener('click', () => {\r\n  alert('This no longer blocks INP as of Chrome 127! \ud83c\udf89');\r\n});\r\n```\r\n\r\nStill repros:\r\n\r\n```json\r\n{\r\n    \"name\": \"script\",\r\n    \"entryType\": \"script\",\r\n    \"startTime\": 13446.699999988079,\r\n    \"duration\": 3763,\r\n    \"navigationId\": \"e754322a-fc20-4220-80f0-dfda1ffebbde\",\r\n    \"invoker\": \"BUTTON#loafAlert.onclick\",\r\n    \"invokerType\": \"event-listener\",\r\n    \"windowAttribution\": \"self\",\r\n    \"executionStart\": 13446.699999988079,\r\n    \"forcedStyleAndLayoutDuration\": 0,\r\n    \"pauseDuration\": 0,\r\n    \"sourceURL\": \"https://inp-demo-dialog.glitch.me/\",\r\n    \"sourceFunctionName\": \"\",\r\n    \"sourceCharPosition\": 37\r\n}\r\n```",
        "user": "rviscomi",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2276429407,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/18",
        "created_at": "2024-08-08T18:34:47Z",
        "updated_at": "2024-08-08T18:34:47Z",
        "body": "Might want to file a crbug instead?",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2276433537,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/18",
        "created_at": "2024-08-08T18:37:41Z",
        "updated_at": "2024-08-08T18:37:41Z",
        "body": "Yeah true, not a spec bug",
        "user": "rviscomi",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2276461758,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/18",
        "created_at": "2024-08-08T18:54:57Z",
        "updated_at": "2024-08-08T18:54:57Z",
        "body": "Reopened https://issues.chromium.org/40275918",
        "user": "rviscomi",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2307330972,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/19",
        "created_at": "2024-08-23T15:33:09Z",
        "updated_at": "2024-08-23T15:36:14Z",
        "body": "Mostly I would expect this is a chromium bug, but I do have some spec questions that this raises:\r\n\r\nWould we expect this to be the time of the first event **dispatched** in the animation frame, or, the time of the first event **created** and then dispatched at any time in the frame.\r\n\r\n(Event dispatch can get re-ordered in limited ways, based on priority or vsync alignment or how synthetic gestures are layered.)\r\n\r\nIn [the chromium implementation](https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/frame/animation_frame_timing_monitor.cc;l=727;drc=82dff63dbf9db05e9274e11d9128af7b9f51ceaa;bpv=1;bpt=1) we just take the platform timestamp of the first UI event dispatched, and don't use the earliest value of any UIEvent dispatched (and I guess those values are also wrong somehow).",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2331894466,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/17",
        "created_at": "2024-09-05T14:45:37Z",
        "updated_at": "2024-09-05T14:45:37Z",
        "body": "The demo page won't consistently report long INP now that the Event Timing duration was fixed for alerts.  You can still make it long and get logged (via input delay) by interacting with the button while the page is blocked.\r\n\r\nAlternatively, just open DevTools console and log all LoAFs with a script for `event-listener`:\r\n\r\n```js\r\nnew PerformanceObserver(list => list.getEntries()\r\n  .flatMap(entry => entry.scripts)\r\n  .filter(s => s.invokerType == \"event-listener\")\r\n  .forEach(s => console.log(s)))\r\n.observe({ type: 'long-animation-frame' });\r\n```\r\n\r\n(It still reproduces, fwiw)",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2447599886,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/20",
        "created_at": "2024-10-30T15:46:06Z",
        "updated_at": "2024-10-30T15:46:06Z",
        "body": "One alternative: We expose timing details for `script` that are >5ms, but what about exposing a `totalScriptDuration` which sums the durations for also scripts which are faster, and make this duration NOT include durations for work such as GC (not sure if all GC is created equal and worth ignoring, i.e. idle time GC vs GC during hot loops).\r\n\r\nThen you could compare `totalScriptDuration` for the LoAF against the `duration` of the LoAF in order to get a general sense: how much of the time for this LoAF is accountable?\r\n\r\nThere might be many reasons beyond GC that affect LoAF durations, and where optimizing scripts wouldn't help.",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2470414631,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/10",
        "created_at": "2024-11-12T12:33:21Z",
        "updated_at": "2024-11-12T12:33:21Z",
        "body": "Even if it's not actionable by developers I think it's worth exposing in someway\r\n\r\nThis is a trace from a 'clean' Chrome profile with two extensions installed \u2013 web vitals one, and other that creates marks / measures for the DevTools Extensibility API to collect \r\n\r\nhttps://trace.cafe/t/cUv2LuXFKq\r\n\r\nLooking at the Custom Tracks we can see the Long Tasks API exposes there's some activity happening even though there's no matching attribution in the corresponding LoAF\r\n\r\nEven if I can't do anything about it as a developer having a clear indication that the time was an extension or even just if there was just a bucket of time that says 'some tasks that we can't tell you about ran' would be helpful because then I know I can't debug them and move onto other things.\r\n\r\n",
        "user": "andydavies",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2470434424,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/10",
        "created_at": "2024-11-12T12:42:35Z",
        "updated_at": "2024-11-12T12:43:08Z",
        "body": "> the Long Tasks API exposes there's some activity\r\n\r\nEven though LoAF Scripts are ~Tasks as per Long Tasks, I know there were some differences between in the details because that API had some unintended cruft.  Much of that was related to splitting Tasks into distinct scripts.  But was there also some \"leakage\" of information related to time spent in extensions?\r\n\r\n> Even if I can't do anything about it as a developer having a clear indication that the time was an extension or even just if there was just a bucket of time that says 'some tasks that we can't tell you about ran' would be helpful because then I know I can't debug them and move onto other things.\r\n\r\nI think this is interesting.  If there is a gap of unaccounted time, it could be:\r\n- scheduling tasks, but for a different iframe and so reported to a different performance timeline\r\n- scheduling work, but outside of scripts (I think animations layout?)\r\n- scheduling scripts, but \"hidden\" i.e. because extensions\r\n- literally Idle time",
        "user": "mmocny",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2470833340,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/10",
        "created_at": "2024-11-12T15:25:33Z",
        "updated_at": "2024-11-12T15:25:33Z",
        "body": "It sounds reasonable to me to add some opaque attribution about non-actionable things",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2478455013,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/16",
        "created_at": "2024-11-15T10:01:20Z",
        "updated_at": "2024-11-15T10:01:20Z",
        "body": "Hi again! I found a way around this in the end but I do have a question on what `sourceCharacterPosition` represents.\r\nEspecially in the context of SPAs e.g. a React app it can point to a position in a minified file. When successfully unminifying it, it sometimes points to `import` statements for ex. which seems confusing.\r\n\r\nSo my question on this would be, is the sourceCharPosition pointing to beginning of a task that is executed by the browser? Meaning that in order to understand the performance issue we would need to also know the rest of the code executed in that task. ",
        "user": "Miz85",
        "is_owner": false,
        "is_contributor": false,
        "repository_id": "w3c/long-animation-frames"
    },
    {
        "id": 2478463656,
        "issue_url": "https://api.github.com/repos/w3c/long-animation-frames/issues/16",
        "created_at": "2024-11-15T10:05:46Z",
        "updated_at": "2024-11-15T10:05:46Z",
        "body": "> Hi again! I found a way around this in the end but I do have a question on what `sourceCharacterPosition` represents. Especially in the context of SPAs e.g. a React app it can point to a position in a minified file. When successfully unminifying it, it sometimes points to `import` statements for ex. which seems confusing.\r\n> \r\n> So my question on this would be, is the sourceCharPosition pointing to beginning of a task that is executed by the browser? Meaning that in order to understand the performance issue we would need to also know the rest of the code executed in that task.\r\n\r\nIt points to the \"entry point\" function, see key point in https://developer.chrome.com/docs/web-platform/long-animation-frames#better-attribution\r\n\r\nAlso see issue #3 which we're currently working on.",
        "user": "noamr",
        "is_owner": false,
        "is_contributor": true,
        "repository_id": "w3c/long-animation-frames"
    }
]